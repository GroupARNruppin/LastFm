# -*- coding: utf-8 -*-
"""LastFmUpduted.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/GroupARNruppin/LastFm/blob/main/LastFmUpduted.ipynb
"""

import pandas as pd
import numpy as np

# יצירת DataFrame של משתמשים עם מזהים
user_ids = np.arange(7624)  # Assuming 7624 users as per the graph nodes count

# רשימת מיקומים במדינות אסיה
asian_locations = [
    'China', 'Japan', 'India', 'South Korea', 'Thailand', 'Vietnam', 'Indonesia', 'Malaysia',
    'Singapore', 'Philippines', 'Pakistan', 'Bangladesh', 'Sri Lanka', 'Nepal', 'Myanmar',
    'Laos', 'Cambodia', 'Mongolia', 'North Korea', 'Bhutan', 'Maldives'
]

# יצירת רשימת מיקומים מדומה
locations = np.random.choice(asian_locations, len(user_ids))

# יצירת DataFrame עם מיקומים מדומים
user_locations_df = pd.DataFrame({
    'id': user_ids,
    'location': locations
})

# שמירת ה-DataFrame לקובץ CSV
file_path = '/data/user_locations_asia.csv'
user_locations_df.to_csv(file_path, index=False)

file_path

"""# טעינת וסקירת הנתונים
בקטע קוד זה, אנו טוענים את קובצי הנתונים ובודקים את השורות הראשונות של כל קובץ כדי להבין את המבנה שלהם.

"""

import pandas as pd
import networkx as nx
import community.community_louvain as community_louvain
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
from mpl_toolkits.axes_grid1 import make_axes_locatable

# Load the datasets
targets_df = pd.read_csv('/data/lastfm_asia_target.csv')
edges_df = pd.read_csv('/data/lastfm_asia_edges.csv')
er_features_df = pd.read_csv('/data/ER_features.csv')
user_locations_df = pd.read_csv('/data/user_locations_asia.csv')  # קובץ המיקומים החדש

# Display the first few rows of each dataframe
print("Targets DataFrame:")
print(targets_df.head())

print("\nEdges DataFrame:")
print(edges_df.head())

print("\nER Features DataFrame:")
print(er_features_df.head())

print("\nUser Locations DataFrame:")
print(user_locations_df.head())

"""# בניית הגרף
בקטע קוד זה, אנו יוצרים גרף ריק ומשתמשים בקובץ הקצוות להוספת הקצוות לגרף.

"""

# Create an empty graph
G = nx.Graph()

# Add edges to the graph
for _, row in edges_df.iterrows():
    G.add_edge(row['node_1'], row['node_2'])

print(f"Graph has {G.number_of_nodes()} nodes and {G.number_of_edges()} edges")

"""# זיהוי קהילות
בקטע קוד זה, אנו משתמשים בשיטת Louvain לזיהוי קהילות בגרף ומוסיפים את המידע על הקהילות לנתוני המשתמשים.

"""

# Apply the Louvain method
partition = community_louvain.best_partition(G)

# Add partition information to the targets dataframe
targets_df['community'] = targets_df['id'].map(partition)

# Display the first few rows with community information
print(targets_df.head())

"""# ניתוח קהילות
בקטע קוד זה, אנו מנתחים את הקהילות שנמצאו ובודקים את החלוקה הגיאוגרפית של המשתמשים בכל קהילה.

"""

# Merge the ER features with the targets DataFrame on 'id'
er_features_df['id'] = er_features_df.index
df_merged = pd.merge(targets_df, er_features_df, on='id')

# Merge the user locations with the merged DataFrame on 'id'
df_merged = pd.merge(df_merged, user_locations_df, on='id')

# הצגת הנתונים הממוזגים עם המיקומים
print("\nMerged DataFrame with Locations:")
print(df_merged.head())

# Group by community and analyze the geographical distribution using 'location' column
community_analysis = df_merged.groupby('community')['location'].value_counts().unstack().fillna(0)
print("\nCommunity Analysis:")
print(community_analysis)

"""# ויזואליזציה של הגרף והקהילות
בקטע קוד זה, אנו מייצרים גרף המציג את הקהילות בצבעים שונים.

מסקנות מהצגת האמצע שלנו: להשתמש בצבעים לא דומים לקהילות


"""

# Load the world map shapefile
world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))

# Filter for Asia
asia = world[(world.continent == 'Asia')]

# Sum communities by location
location_community_sum = df_merged.groupby('location')['community'].count().reset_index()
location_community_sum.columns = ['location', 'count']

# Merge with geo data
asia = asia.merge(location_community_sum, how='left', left_on='name', right_on='location')

# Plotting the map
fig, ax = plt.subplots(1, 1, figsize=(15, 10))
divider = make_axes_locatable(ax)
cax = divider.append_axes("right", size="5%", pad=0.1)

asia.boundary.plot(ax=ax)
asia.plot(column='count', ax=ax, legend=True, cax=cax, cmap='viridis',
          legend_kwds={'label': "Number of Users by Country",
                       'orientation': "vertical"})

plt.title('Community Distribution Across Asian Countries')
plt.show()

# Draw the graph with community colors and legend
pos = nx.spring_layout(G)
cmap = plt.get_cmap('tab20')
unique_communities = set(partition.values())
colors = [cmap(i / len(unique_communities)) for i in range(len(unique_communities))]
color_map = {comm: colors[i] for i, comm in enumerate(unique_communities)}

node_colors = [color_map[partition[node]] for node in G.nodes]

plt.figure(figsize=(12, 12))
nx.draw_networkx(G, pos, node_color=node_colors, with_labels=False, node_size=30, edge_color='gray', alpha=0.7)

# Create legend
handles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color_map[comm], markersize=10)
           for comm in unique_communities]
labels = [f"Community {comm}" for comm in unique_communities]
plt.legend(handles, labels, loc='best', fontsize='large')

plt.title("Network Graph with Community Detection", fontsize=16)
plt.show()

"""**צמצום צמתים- השתמשות ב-Threshold:**

כדי לצמצם את הצמתים ולהפוך את הגרף לברור יותר, השתמשנו בטכניקות של סינון פרטים על בסיס מדדי דמיון. לדוגמה, בחרנו רק את הצמתים החשובים ביותר בכל קהילה וסיננו צמתים עם פחות קשרים.
"""

# Get the degree centrality of nodes
degree_centrality = nx.degree_centrality(G)

# Define a threshold to filter nodes
threshold = 0.01  # This can be adjusted

# Filter nodes based on degree centrality
filtered_nodes = [node for node, centrality in degree_centrality.items() if centrality > threshold]

# Create a subgraph with filtered nodes
G_filtered = G.subgraph(filtered_nodes)

# Draw the graph with community colors and legend
pos = nx.spring_layout(G_filtered)
cmap = plt.get_cmap('tab20')
unique_communities = set(partition.values())
colors = [cmap(i / len(unique_communities)) for i in range(len(unique_communities))]
color_map = {comm: colors[i] for i, comm in enumerate(unique_communities)}

node_colors = [color_map[partition[node]] for node in G_filtered.nodes]

plt.figure(figsize=(12, 12))
nx.draw_networkx(G_filtered, pos, node_color=node_colors, with_labels=False, node_size=30, edge_color='gray', alpha=0.7)

# Create legend
handles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color_map[comm], markersize=10)
           for comm in unique_communities]
labels = [f"Community {comm}" for comm in unique_communities]
plt.legend(handles, labels, loc='best', fontsize='large')

plt.title("Network Graph with Community Detection (Filtered)", fontsize=16)
plt.show()

"""בקוד הבא השתמשנו בשני אתרי מחקר

אתר 1- מציג את הז'אנר שהפיקו אותו הכי הרבה במדינות באסיה בשנת 2019

אתר 2- מגיג את הז'אנרים המושמעים ביותר באסיה בשנת 2024

ייצרנו מפה אינטרקטיבית שמציגה כל מדינה באסיה מהאתרים עם הז'אנר המועדף עליה
"""

import folium

# Initialize map centered around Asia
m = folium.Map(location=[20, 100], zoom_start=4)

# Data for countries and their music genres
countries = {
    "China": "Rock, Pop",
    "Hong Kong": "Cantopop",
    "India": "Indian Pop, Bollywood",
    "Indonesia": "Dangdut, Rock",
    "Japan": "J-Pop, Downtempo/Experimental/Punk",
    "Nepal": "Folk, Ambient/Hindustani/New Age",
    "Singapore": "Pop, Punk",
    "South Korea": "K-Pop",
    "Sri Lanka": "Pop Rock/Vocal",
    "Vietnam": "V-Pop, Folk/Pop"
}

# Country coordinates for plotting
coords = {
    "China": [35.8617, 104.1954],
    "Hong Kong": [22.3193, 114.1694],
    "India": [20.5937, 78.9629],
    "Indonesia": [-0.7893, 113.9213],
    "Japan": [36.2048, 138.2529],
    "Nepal": [28.3949, 84.1240],
    "Singapore": [1.3521, 103.8198],
    "South Korea": [35.9078, 127.7669],
    "Sri Lanka": [7.8731, 80.7718],
    "Vietnam": [14.0583, 108.2772]
}

# Colors for each country
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'darkblue', 'darkgreen', 'cadetblue']

# Add markers for each country with genre and country name as tooltip and label
for idx, (country, genre) in enumerate(countries.items()):
    folium.Marker(
        location=coords[country],
        popup=genre,
        tooltip=country,
        icon=folium.Icon(color=colors[idx % len(colors)])
    ).add_to(m)
    folium.map.Marker(
        coords[country],
        icon=folium.DivIcon(
            icon_size=(300,36),
            icon_anchor=(0,0),
            html=f'<div style="font-size: 16pt; color: {colors[idx]};"><b>{country}</b>: {genre}</div>',
        )
    ).add_to(m)

# Save the map to an HTML file
m.save("/data/asia_music_genres_updated_map_bold.html")

# Display the map
m